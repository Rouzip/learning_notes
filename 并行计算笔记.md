## 并行正则采样算法

设有n个数据，P个处理器，以及均匀分布在P个处理器上的n个数据

1. 每个处理器将自己的$\frac{n}{p}$ 个数据先快排，得到局部有序
2. **每个**处理器从排好序的序列中选取1，w，2w……，$(P-1)w$个数据作为代表元素$w = \frac{n}{P^2}$
3. 将代表元素送到$P_0$ 处理器，做n路归并排序，选取排序后的主元。(P-1, 2(P-1),……,(P-1)(P-1))
4. 处理器$P_0$将主元发送到其余P-1个处理器中
5. 每个处理器将自己所拥有的数据段进行切分，依据是主元的大小关系
6. 处理器分别发送数据段给对应的处理器（主元相当于分割开整个数据段）
7. 每个处理器相当于再来一次P路归并

## Cannon乘法

根据处理器数目将数据进行分块，($0 \leq i,j \leq \sqrt{p}-1$)$A_{i,j}, B_{i,j}$

1. $A_{i,j}$向左移动i步，$B_{i,j}$向上移动j步（第一行，第一列都不动，后面的每行每列都移动其相应的步数）
2. 每次执行一次乘法之后，$A_{i,j}$ 向左移动**一**步，$B_{i,j}$向上移动**一**步
3. 重复2步，总共执行$\sqrt{p}$次乘加运算

其中move函数对于奇偶和位置对待不同，if判断中先判断是不是开头，然后判断是不是偶数结尾，然后判断奇数结尾，之后按顺序处理偶数号处理器和奇数号处理器（偶数先发后收；奇数先在buffer做备份，接受右邻接受，最后buffer发送到左邻）

## Fox乘法

先像Cannon乘法一样进行分块。

1. $A_{i,i}$向所在**行**进行广播，让每个处理器获得拷贝（该步只进行一次）
2. 处理器将受到的数据与B块进行乘加运算
3. B块整体上一步
4. 如果$A_{i,j}$ 是上次第i行广播的块，该次需要改变广播块为$A_{i,(j+1)mod\sqrt{p}}$，然后向所在行的各个处理器进行广播
5. 跳转到第二步，重复执行$\sqrt{p}-1$次

## Systolic乘法

每行数据保持一个节拍的差距，一拍一拍按照顺序将数据送入到处理器之中，处理器获得数据即进行运算

处理器内部首先需要初始化0，每次运算结果都要进行记录，其结果即矩阵$C_{n,n}$ 各项之和。





















