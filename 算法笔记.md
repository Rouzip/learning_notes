问题的求解，P，NP，NPC之间的关系。

如何证明NPC问题：

1. 证明为NP问题
2. 验证NP中的问题都可以规约到L中去。

使用更好的方法，使用传递性来证明NPC问题。

1. 验证NP问题
2. 在已知NPC问题中选择一个
3. 将当前的问题约简到已知的那个NPC问题中去

顶点覆盖问题



## 一

算法的复杂性

渐进的复杂性（时间空间）O上界 Ω下界 

f(n)  g(n)

递归关系求解：迭代，替换法，递归树，主定理法（有前提）

> 使用向前替换法：先猜测出一个表达式，然后使用数学归纳法进行证明
>
> 反向替换法：使用反向替换，将替换出来的式子带进方程，然后导出关系式进行化简
>
> 二阶常系数线性递推式：使用线性方程求解

主定理情况分类：

![主定理](https://raw.githubusercontent.com/Rouzip/learning_notes/master/PICTURES/%E4%B8%BB%E5%AE%9A%E7%90%86.png)

回溯：状态空间=>深度优先搜索

>步骤：
>
>1. 针对所给问题，定义问题的解空间
>2. 确定易于搜索的解空间结构
>3. 以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索

分支界限法

> 步骤：
>
> 1. 针对所给问题，定义问题的解空间
> 2. 确定易于搜索的解空间结构
> 3. 以广度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索

比较回溯与分支限界法

> 1. 回溯法的求解目标是找出空间树中的满足约束同条件的所有解，而分支界限法是尽快找出满足约束条件的一个解
> 2. 回溯采用深度优先，分支界限采用广度优先或最小耗费优先
> 3. 回溯中，结点不可扩展就为死节点，然后回溯到活结点处，并让他成为扩展结点；分支界限法每个活结点只有一次可以成为扩展结点，活结点一旦成为扩展结点，就一次性生成其所有的子结点
> 4. 分支界限法的存储要求比回溯法大得多

图的部分掌握基本算法：关键路径，拓扑排序，最长路径（结合动态规划）

关键路径：找到拓扑排序和逆拓扑排序，然后结合找出其中的关键节点

拓扑排序：数据结构中的算法就可以，每次找出其中的一个无入度的结点然后一个个添加到集合之中。

最短路径：可以使用Prim算法或者Kruskal算法

最长路径：对应的改造最短路径算法，将选出最短改为选出最长

动态规划：最优子结构，子问题重叠，没有后向性（只看当前状态

最优子结构性质：某个问题的最优解包含着其子问题的最优解。

分治法（快排，归并排，最近点对，凸包问题

```python
def quickSort(nums,start,end):
    '''
    快速排序
    '''
    if start < end:
        i,j = start,end
        base = nums[i]
    else:
        return
    
    while i < j:
        while i < j and nums[j] >= base:
            j -= 1
        nums[i] = j
        while i < j and nums[i] <= base:
            i += 1
        nums[j] = nums[i]
    nums[i] = base
    quickSort(nums, start, i-1)
    qucikSort(nums, j+1, end)
    return nums
```



```python
def MergeSort(nums):
    '''
    归并排序
    '''
    if len(nums) <= 1:
        return nums
    def mergesort(left,right):
        result, left, right = deque(), deque(left), deque(right)
        while left and right:
            result.append(left.popleft() if left <= right else right.popleft())
        result.extend(right if right else left)
        return result
    mid = int(len(nums) / 2)
    left = mergeSort(nums[:mid])
    right = mergeSort(nums[mid:])
    return mergesort(left, right)
```

变治法：实例化简，改变表现（堆排序，问题化简

减治法：折半查找$\theta(log_2n)$，第k大（小）数

> 减治法：
>
> 1. 减一个常数因子：减1（插入排序
> 2. 减一个常因子：减去因子2（例如折半查找
> 3. 减可变规模（欧几里得算法

贪心算法：局部最优不一定能导出全局最优，子问题的最优解需要包含在问题的答案之中。（活动安排的例子，汽车的加油，最短路径，最小生成树，最大生成树，最长路径，0/1背包【可能得不到最优解】

动态规划：最优子结构，首先算出来以后将要使用的数据，简化运算。（0/1背包，lcs，最短路径问题，最优二叉查找树，Watshall和Floyed算法

传递闭包：如果从第i个顶点到第j个顶点之间存在一条有效的有向路径，则$nums[i][j]$ 为1，否则为0

图论：深度/广度优先，连通分量

分支限界/回溯：0/1背包，如何定界，TSP问题，（先进先出，优先队列【搜索顺序】

NPC：掌握P,NP,NPC的关系，NP-hard等的关系。看是否有假设，有假设则三者相同。

 P类问题是一类能够用（确定性的）算法在多项式的时间内求解的判定问题。

NP问题是一类可以用不确定多项式算法求解的判定问题。

NP完全问题：

1. 他属于NP类型
2. NP中的任何问题都能够在多项式时间内化简为D

> 证明：
>
> 1. 证明他属于NP问题
> 2. 证明NP中的每一个问题都能在多项式的时间内化简为所讨论的问题

